#ifndef SRC_S21_SMARTCALC_V1_H
#define SRC_S21_SMARTCALC_V1_H

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/**
 * @mainpage Part 1. Реализация SmartCalc v1.0
 * Необходимо реализовать программу SmartCalc v1.0.\n
 * Part 2. Дополнительно. Кредитный калькулятор\n
 * Part 3. Дополнительно. Депозитный калькулятор
 */

/**
 * @brief Структура Stack
 */
typedef struct Stack {
  double value;  ///< Числовое значение неизвестного при type == 3
  int oper;  ///< Код оператора: 1 - сложение "+", и т.д. (см. parser())
  int type;  ///< Тип элемента стека: 2 - оператор, 3 - число или переменная (х)
  struct Stack* next;  ///< Указатель на следующий элемент списка
} Stack;

/**
 * @brief Инициализация элемента стека
 * @param new_stack указатель на переменную, помещаемую в стек
 * @return указатель на начало стека, в который добавили новый элемент
 */
Stack* stack_init_elem(Stack* new_stack);

/**
 * @brief Инициализация полей структуры
 * @param type значение поля "type" для элемента
 * @param value значение поля "value" для элемента
 * @param stack указатель на начало стека, где находится элемент
 * @return указатель на начало стека, в котором хранится элемент
 */
Stack* stack_init_value(int type, double value, Stack* stack);

/**
 * @brief Добавляет элемент в стек
 * @param new_elem указатель на новый элемент
 * @param stack указатель на начало исходного стека
 * @return указатель на результирующий стек
 */
Stack* stack_push(Stack* new_elem, Stack* stack);

/**
 * @brief Извлекает элемент из стека (без сохранения элемента)
 * @param stack указатель на начало исходного стека
 * @return указатель на результирующий стек
 */
Stack* stack_pop(Stack* stack);

/**
 * @brief Переворачивает стек задом наперед
 * @param stack указатель на начало исходного стека
 * @return указатель на перевернутый стек
 */
Stack* stack_reverse(Stack* stack);

/**
 * @brief Очищает стек
 * @param stack указатель на начало стека
 */
void stack_free(Stack* stack);

/**
 * @brief Обрабатывает унарный оператор (+ или -), добавляя его в стек
 * @param top указатель на начало стека с лексемами
 * @return указатель на результирующий стек
 */
Stack* unary_sign(Stack* top);

/**
 * @brief Получает число из цифр в строке
 * @param str выражение в виде текстовой строки
 * @param pos позиция первой встреченной цифры
 * @return число, полученное из цифр, стоящих рядом
 */
double get_number(char* str, int* pos);

/**
 * @brief Получает приоритет для двух операторов, взятых из стека
 * @param i код первого оператора
 * @param j код второго оператора
 * @return приоритет первого оператора ко второму
 */
int get_priority(int i, int j);

/**
 * @brief Проверяет, что арифметическая операция записана верно
 * @details Ошибки:
 * - 0 - ОК
 * - 8 - ошибка в написании оператора
 * @param str выражение в виде текстовой строки
 * @param rigth позиция в строке, проверять от нее к началу строки
 * @param left позиция в строке, проверять от нее к концу строки
 * @return код ошибки
 */
int check_oper(char* str, int rigth, int left);

/**
 * @brief Проверяет, что функция записана верно
 * @details Ошибки:
 * - 0 - ОК
 * - 7 - ошибка в написании имени функции
 * @param str выражение в виде текстовой строки
 * @param pos позиция в строке, откуда начинать проверку
 * @return код ошибки
 */
int check_func(char* str, int* pos);

/**
 * @brief Проверяет введенный текст на соответствие правилам записи
 * математических выражений
 * @details Ошибки:
 * - 0 - ОК
 * - 6 - пустые скобки у функции или в начале строки
 * - 7 - ошибка в написании имени функции
 * - 8 - ошибка в написании оператора
 * - 9 - несоответствие скобок
 * @param str выражение в виде текстовой строки
 * @return код ошибки
 */
int validate_str(char* str);

/**
 * @brief Разбирает введенное выражение на лексемы (в порядке их следования в
 * выражении)
 * @param str выражение в виде текстовой строки
 * @param argum значение переменной Х
 * @return указатель на начало стека с лексемами
 */
Stack* parser(char* str, double* argum);

/**
 * @brief Реализует нужное вычисление для лексем, извлеченных из стека
 * @param top указатель на начало стека с лексемами
 * @return вычисленное значение
 */
double calc_from_stack(Stack* top);

/**
 * @brief Вычисляет арифметическую операцию
 * @param op1 численнное значение первого операнда
 * @param op2 численнное значение второго операнда
 * @param oper код оператора
 * @return вычисленное значение
 */
double calc_arithmetic(double op1, double op2, int oper);

/**
 * @brief Вычисляет функцию
 * @param arg численное значение аргумента выичсляемой функции (х)
 * @param oper код функции F(), применяемой к аргументу
 * @return вычисленное значение функции F(x)
 */
double calc_function(double arg, int oper);

/**
 * @brief  Переводит в обратную польскую нотацию
 * @param top указатель на начало стека с разобранным на лексемы выражением
 * @return стек с лексемами в обратной польской нотации
 */
Stack* reverse_polish(Stack* top);

/**
 * @brief Основная функция калькулятора
 * @details Ошибки:
 * - 0 - ОК
 * - 6 - пустые скобки у функции или в начале строки
 * - 7 - ошибка в написании имени функции
 * - 8 - ошибка в написании оператора
 * - 9 - несоответствие скобок
 * @param str выражение в виде текстовой строки
 * @param result вычисленное значение выражения
 * @return код ошибки
 */
int smart_calc(char* str, double* result);

// void stack_output(Stack* stack);

#endif  // SRC_S21_SMARTCALC_V1_H